<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session 0e28b8d6-2a10-4464-bb7c-bcc1b4c9e932 (2025-12-11 21:14Z) -->

# WIG Design System Bridge Implementation Plan (2025-12-11 21:14Z)

_**User (2025-12-11 21:18Z)**_

I will be using sandpack to make this. Any flaws you can see?

Plan: WIG - Figma/GitHub Design System Bridge
A Next.js 15 application that syncs design tokens and components bidirectionally between Figma and GitHub, using branch-based workflows and PR creation for safe, reviewable changes.
Steps
1. Scaffold Next.js 15 app with App Router - Initialize with TypeScript, Tailwind, and shadcn/ui; configure OAuth providers for Figma and GitHub authentication using NextAuth.js.
2. Build Figma integration layer - Create adapters in lib/figma/ using figma-api to read Variables (tokens) and Styles, extracting colors, spacing, typography, radius, and animation values.
3. Implement token engine with DTCG format - Build transformation pipeline in lib/tokens/ using style-dictionary v5 to convert between Figma's format and W3C Design Tokens Community Group (DTCG) spec.
4. Create GitHub operations layer - Implement branch creation, file commits, and PR workflows in lib/github/ using @octokit/rest - enforce branch-only writes (never main).
5. Build token management UI - Create dashboard pages at app/(dashboard)/projects/[id]/tokens/ for viewing, editing, and diffing tokens with visual previews.
6. Implement sync workflow with conflict resolution - Create app/(dashboard)/projects/[id]/sync/ for bidirectional sync, showing diffs and creating PRs with generated GitHub Actions for Figma deployment.
Further Considerations
1. Figma write access requires Pro/Org plan - Should WIG support read-only mode for free Figma accounts, with GitHub → Figma sync as a "premium" feature?
2. Approval workflow for Figma deployment - Recommend: GitHub PR merge triggers Action that pushes to Figma, ensuring code review gates design system changes. Alternatively, separate "publish to Figma" button post-merge?
3. Component preview scope - MVP could use iframe-based rendering with injected CSS variables; defer full visual editing (monaco/drag-drop) to v2?

---

_**Agent (model copilot/gpt-5.2)**_

**Considering components sync**

I think syncing Figma components to code might be unrealistic. The process isn't trivial, and it seems like we might only handle metadata instead. I need to answer while ensuring file references aren’t necessary. It feels like taking a careful approach is crucial, especially since the details around syncing need to be thoroughly understood. Let’s keep this straightforward without using emojis, so I can maintain clarity in my response!A few big “gotchas” jump out—mostly around Sandpack feasibility, OAuth, and what “bidirectional” really means for Figma.

**Sandpack / runtime constraints**
- Sandpack is great for UI prototyping, but OAuth + Octokit writes + Figma access tokens require a real server (secrets, redirects, callbacks). In pure Sandpack you can’t safely store client secrets or run NextAuth callbacks reliably.
- Style Dictionary v5 is Node-ish and can be heavy; running it in-browser is painful and running it on Edge runtimes may break. You’ll likely want a server/worker step for transforms and validation.
- Practical approach: use Sandpack for the token UI/diff UX, but have a separate hosted API (Next.js route handlers on Vercel, or a tiny backend) that does auth + Figma/GitHub operations.

**Figma “write” reality**
- Figma API write support is much more limited than read. Tokens via Variables are doable; “components bidirectionally” is the risky claim (true component sync is usually a separate compiler/problem space).
- Variables have Collections + Modes + variable aliasing; mapping that cleanly to DTCG (“themes”/modes, alias resolution) needs upfront decisions or you’ll get drift and hard-to-resolve diffs.

**Auth & permissions pitfalls**
- NextAuth + two providers is fine, but you’ll want to be explicit about token storage/refresh (Figma tokens expire; GitHub fine-grained permissions differ). Plan for refresh, rotation, and “reconnect”.
- Consider a GitHub App instead of OAuth for repo writes/PRs: better permission scoping, easier org installs, and safer automation.

**“Bidirectional sync” needs a source-of-truth model**
- Without a clear policy you’ll hit loops: Figma → GitHub → Figma produces non-idempotent reformatting/renaming changes.
- You need: canonical token IDs, stable ordering/formatting, a deterministic serializer, and a conflict policy (per-token, per-collection, or “last writer wins” with audit trail).

**Branch/PR workflow edge cases**
- “Never write to main” is good, but you must also guard against: existing open PRs, rebasing conflicts, force-pushes, and concurrent sync runs. You’ll want locking (per project) and a “sync from commit X / figma version Y” marker.
- If merges trigger “push to Figma”, remember Actions need Figma credentials: use protected environments + required reviewers if you want a real approval gate.

**Token engine considerations**
- DTCG spec support across tools is still uneven; Style Dictionary compatibility with full DTCG features (modes, composites, typography objects) can be bumpy. Budget time for custom transforms + schema validation.
- Decide early on file layout in the repo (single `tokens.json` vs per-category files) because it drives diffs and conflict resolution quality.

**MVP scope recommendation**
- MVP: “Tokens bidirectional, components read-only metadata” is much more achievable than “components bidirectional”.
- Ship read-only Figma mode by default, then add Figma write as an opt-in feature (and separate it behind stronger safeguards).

If you want, I can suggest a concrete minimal architecture that works well with Sandpack (UI in Sandpack + hosted `/api` for auth/sync) and a token data model that cleanly maps Figma Collections/Modes ↔ DTCG themes.

---

