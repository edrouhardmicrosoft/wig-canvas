<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session eeab000a-4e3f-4b75-a3ed-52025ac53b16 (2025-12-11 21:19Z) -->

# WIG project architecture and GitHub integration discussion (2025-12-11 21:19Z)

_**User (2025-12-11 21:20Z)**_


I have already installed next 15 and shadcn. Does the rest of this look good?

----
Exactly. That's the core loop:

```
┌─────────────────────────────────────────────────────────────────┐
│                         WIG                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│   │   VIEW      │    │   EDIT      │    │   PUSH      │        │
│   │             │    │             │    │             │        │
│   │  Sandpack   │ →  │  Chat +     │ →  │  Branch →   │        │
│   │  renders    │    │  Live code  │    │  PR → Merge │        │
│   │  from repo  │    │  changes    │    │             │        │
│   └─────────────┘    └─────────────┘    └──────┬──────┘        │
│         ↑                                      │               │
│         │            ┌─────────────┐           │               │
│         │            │   FIGMA     │ ←─────────┘               │
│         │            │   SYNC      │  (GitHub Action           │
│         │            │             │   on merge)               │
│         │            └─────────────┘                           │
│         │                   │                                  │
│         └───────────────────┘                                  │
│              (tokens.json)                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Simplified Architecture

````
app/
├── page.tsx                    # Landing / project selector
├── [project]/
│   ├── page.tsx               # Design system viewer (Sandpack)
│   ├── components/            # Browse & edit components
│   └── tokens/                # View/edit design tokens
├── api/
│   ├── chat/route.ts          # AI for code changes
│   ├── github/
│   │   ├── branch/route.ts    # Create feature branch
│   │   ├── commit/route.ts    # Commit changes
│   │   └── pr/route.ts        # Open PR
│   └── figma/
│       └── sync/route.ts      # Push tokens to Figma
lib/
├── github.ts                   # Octokit wrapper
├── figma.ts                    # Figma API wrapper
└── tokens.ts                   # DTCG transform
````

## The Three Core APIs

### 1. Branch + Commit

````typescript
import { Octokit } from '@octokit/rest';

export async function createBranchAndCommit({
  repo,
  owner,
  filePath,
  content,
  message,
}: {
  repo: string;
  owner: string;
  filePath: string;
  content: string;
  message: string;
}) {
  const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

  // Get main branch SHA
  const { data: ref } = await octokit.git.getRef({
    owner,
    repo,
    ref: 'heads/main',
  });

  // Create feature branch
  const branchName = `wig/design-update-${Date.now()}`;
  await octokit.git.createRef({
    owner,
    repo,
    ref: `refs/heads/${branchName}`,
    sha: ref.object.sha,
  });

  // Get current file (if exists) for its SHA
  let fileSha: string | undefined;
  try {
    const { data } = await octokit.repos.getContent({
      owner,
      repo,
      path: filePath,
      ref: branchName,
    });
    if (!Array.isArray(data)) fileSha = data.sha;
  } catch {}

  // Commit the change
  await octokit.repos.createOrUpdateFileContents({
    owner,
    repo,
    path: filePath,
    message,
    content: Buffer.from(content).toString('base64'),
    branch: branchName,
    sha: fileSha,
  });

  return { branchName };
}
````

### 2. Create PR

````typescript
export async function createPR({
  repo,
  owner,
  branchName,
  title,
  body,
}: {
  repo: string;
  owner: string;
  branchName: string;
  title: string;
  body: string;
}) {
  const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

  const { data: pr } = await octokit.pulls.create({
    owner,
    repo,
    title,
    body,
    head: branchName,
    base: 'main',
  });

  return { prUrl: pr.html_url, prNumber: pr.number };
}
````

### 3. Figma Sync (GitHub Action)

````yaml
name: Sync to Figma

on:
  push:
    branches: [main]
    paths:
      - 'tokens/**'

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Push tokens to Figma
        run: |
          curl -X POST "https://api.figma.com/v1/files/${{ secrets.FIGMA_FILE_ID }}/variables" \
            -H "X-Figma-Token: ${{ secrets.FIGMA_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d @tokens/figma-variables.json
````

## Minimal UI Flow

````tsx
'use client';

import { useState } from 'react';
import { useChat } from 'ai/react';
import { SandpackProvider, SandpackPreview, useSandpack } from '@codesandbox/sandpack-react';

function Editor({ repoFiles }: { repoFiles: Record<string, string> }) {
  const { sandpack } = useSandpack();
  const [branch, setBranch] = useState<string | null>(null);
  const [prUrl, setPrUrl] = useState<string | null>(null);

  const { messages, input, handleSubmit, handleInputChange } = useChat({
    api: '/api/chat',
    body: { code: sandpack.files['/App.js']?.code },
    onToolCall: async ({ toolCall }) => {
      if (toolCall.toolName === 'update_code') {
        sandpack.updateFile('/App.js', toolCall.args.code);
      }
    },
  });

  const pushChanges = async () => {
    const code = sandpack.files['/App.js']?.code;
    
    // 1. Create branch + commit
    const res = await fetch('/api/github/commit', {
      method: 'POST',
      body: JSON.stringify({
        filePath: 'components/AlbumCard.tsx',
        content: code,
        message: 'Update AlbumCard via WIG',
      }),
    });
    const { branchName } = await res.json();
    setBranch(branchName);

    // 2. Create PR
    const prRes = await fetch('/api/github/pr', {
      method: 'POST',
      body: JSON.stringify({
        branchName,
        title: 'Design system update from WIG',
        body: '## Changes\n\nUpdated via WIG design editor.',
      }),
    });
    const { prUrl } = await prRes.json();
    setPrUrl(prUrl);
  };

  return (
    <div className="flex h-screen">
      {/* Preview */}
      <div className="flex-1 bg-gray-100 flex items-center justify-center">
        <SandpackPreview />
      </div>

      {/* Sidebar */}
      <div className="w-96 border-l flex flex-col">
        {/* Chat */}
        <div className="flex-1 overflow-auto p-4">
          {messages.map((m) => (
            <div key={m.id} className="mb-2">{m.content}</div>
          ))}
        </div>
        
        <form onSubmit={handleSubmit} className="p-4 border-t">
          <input
            value={input}
            onChange={handleInputChange}
            className="w-full p-2 border rounded"
            placeholder="Make the corners sharper..."
          />
        </form>

        {/* Push to GitHub */}
        <div className="p-4 border-t">
          <button
            onClick={pushChanges}
            className="w-full py-2 bg-green-600 text-white rounded"
          >
            Push to GitHub
          </button>
          
          {prUrl && (
            <a href={prUrl} target="_blank" className="block mt-2 text-blue-600 text-sm">
              View PR →
            </a>
          )}
        </div>
      </div>
    </div>
  );
}
````

## Summary: What WIG Actually Is

| Layer | Tool | Purpose |
|-------|------|---------|
| **View** | Sandpack | Render components from repo |
| **Edit** | Chat + AI | Natural language → code changes |
| **Branch** | Octokit | Never touch main directly |
| **Review** | GitHub PR | Human approval gate |
| **Deploy** | GitHub Action | Merge triggers Figma sync |

That's the whole thing. No Storybook complexity, no custom preview infrastructure—just Sandpack + GitHub + Figma APIs wired together with a chat interface.

Want me to scaffold this out as a starter repo?

---

_**Agent (model copilot/gpt-5.2)**_

**Clarifying file formatting rules**

I need to follow the final formatting guidelines regarding file paths, especially since I can't reference actual files directly. It's advised to avoid specific file references unless necessary and instead talk about conceptual paths. However, I might need to use markdown links when mentioning files in the user's workspace. I should focus on the architecture and provide high-level recommendations, like using the new `octokit` package and ensuring defensive coding practices. I'll keep it general!**Addressing content retrieval and Sandpack issues**

I’ve realized that I need to handle content retrieval errors like 404 properly. For committing multiple files, I might want to consider using `createTree` and `commit`. When discussing Sandpack, I can't render from an external repository without fetching and transforming the files first, which might lead to issues with Next/React server components. It's worth mentioning that Sandpack runs client-side and can't access private repos, so server-side fetching is necessary. Using tools like the "Sandpack bundler" or dynamic imports could provide solutions. I'll explore options, including `@codesandbox/sandpack-react`.**Integrating Chat tools and API usage**

I need to discuss the Chat tool calling process, using `update_code` for integrating AI function calls. I should send file content and request the LLM to output a patch in a unified diff format to reduce conflicts and apply it with `diff-match-patch`. Validation should be carried out via TypeScript or ESLint. Regarding the GitHub API, I should opt for short-lived installation tokens instead of PATs for better security. For Figma, using the official endpoint instead of direct curl would be more effective. Finally, I want to ensure that only changes to tokens trigger specific actions.**Evaluating scaffolding and architecture**

The user already asked if they want scaffolding, so I need to respond affirmatively. I believe a loop is good, but I'd recommend making 6-8 tweaks. The user mentioned they installed Next 15 and Shadcn, so I can evaluate their setup as coherent. I should highlight important points like authentication, differences between Sandpack and actual Next code, file transformations, and specifics on the Figma API. I’ll provide a concise, bullet-point response with suggested next steps, avoiding emojis, and I’ll only mention the model if they ask.Yes — the overall loop and separation (View → Edit → Push + “sync on merge”) is solid, and it’s a good “minimum viable infra” compared to Storybook-heavy setups.

A few things I’d tighten up before you scaffold it:

- **Auth & security boundary (biggest gap):** don’t ship with a long-lived `GITHUB_TOKEN` that can write to arbitrary repos/paths. Use a **GitHub App** (installation token, repo allowlist), and require a signed-in user (NextAuth/Clerk/etc). Enforce: allowed `owner/repo`, allowed `filePath` prefixes, max payload sizes, rate limits.
- **Sandpack realism:** Sandpack can preview a *component sandbox*, but it won’t “render from repo” for arbitrary Next 15 App Router code without constraints. In practice you’ll want one of:
  - a **controlled preview harness** (React/Vite-style sandbox) that imports the component(s) you’re editing, or
  - a “compiled preview” path (build/run a preview app, iframe it).
  Otherwise you’ll hit issues with RSC, Next-only modules, dynamic imports, env usage, CSS/tooling assumptions, etc.
- **Code-change format:** instead of sending “entire file content” around, have the model produce a **unified diff** (or structured edits), then apply it server-side and re-run TS/ESLint checks. This reduces accidental overwrites and makes review safer.
- **GitHub writes:** `createOrUpdateFileContents` is fine for a single file, but you’ll quickly want “commit multiple files” (tokens + component + docs). Plan a path using `git.createTree` → `git.createCommit` → `git.updateRef`.
- **Next route handler runtime:** your snippet uses `Buffer.from(...)`. That implies **Node runtime**, not Edge. Make sure those routes opt into Node where needed (and that your AI route does too, if it uses Node-only deps).
- **PR ergonomics:** include metadata in PR body (what prompt, what files, before/after screenshots if possible). Also consider opening PRs in **draft** by default.
- **Figma sync correctness:** the “variables” API shape/endpoint has been evolving; treat the YAML as a placeholder and validate the current Figma Variables API + auth headers. Also consider making the Action run on `pull_request` merge (or `push` to `main` is OK) but ensure it’s **idempotent** and won’t clobber manual Figma edits unexpectedly.
- **Tokens as source of truth:** be explicit: is `tokens.json` canonical and Figma derives from it, or vice versa? If it’s bidirectional, you’ll need conflict rules and provenance tracking.

If you want, I can scaffold this in your current Next 15 app with:
- a minimal “project viewer” route using Sandpack as a harness,
- route handlers for GitHub App auth + branch/commit/PR,
- a stubbed tokens pipeline + Action wired to run on merge.

---

